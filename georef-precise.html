<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Colonial Bronx 1750 — Precise Mesh Warp Georeferencing</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: system-ui, sans-serif; }
    #map { width: 100%; height: 100%; }

    /* Overlay canvas sits on top of the map, under the markers */
    #overlay-canvas {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 1;
    }

    /* ── Top bar ─────────────────────────────────────────── */
    .top-bar {
      position: fixed; top: 12px; right: 12px; z-index: 10;
      display: flex; gap: 8px; align-items: center;
    }
    .btn {
      padding: 8px 14px; border: none; border-radius: 6px; cursor: pointer;
      font-size: 13px; font-weight: 600; color: #fff;
      backdrop-filter: blur(8px); transition: transform .1s;
    }
    .btn:hover { transform: scale(1.04); }
    .btn--primary { background: rgba(30,110,230,.88); }
    .btn--secondary { background: rgba(60,60,60,.78); }

    /* ── Bottom bar ──────────────────────────────────────── */
    .bottom-bar {
      position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%);
      z-index: 10; display: flex; gap: 16px; align-items: center;
      background: rgba(20,20,20,.82); backdrop-filter: blur(10px);
      padding: 10px 20px; border-radius: 12px; color: #eee; font-size: 13px;
    }
    .bottom-bar label { white-space: nowrap; }
    .bottom-bar input[type=range] { width: 140px; accent-color: #4a9eff; }

    /* ── Control point list ───────────────────────────────── */
    .cp-list {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      background: rgba(20,20,20,.85); backdrop-filter: blur(10px);
      padding: 10px 14px; border-radius: 10px; color: #eee;
      font-size: 11px; max-height: calc(100vh - 100px); overflow-y: auto;
      min-width: 260px;
    }
    .cp-list h3 { font-size: 14px; margin-bottom: 4px; color: #ffc107; }
    .cp-list .subtitle { color: #aaa; font-size: 11px; margin-bottom: 8px; }
    .cp-list h4 { margin: 8px 0 4px; color: #4a9eff; font-size: 12px; }
    .cp-item {
      display: flex; align-items: center; gap: 6px;
      padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,.08);
      cursor: pointer;
    }
    .cp-item:hover { background: rgba(255,255,255,.05); }
    .cp-item .dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    .cp-item .name { flex: 1; }
    .cp-item .coords { color: #888; font-family: monospace; font-size: 10px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <canvas id="overlay-canvas"></canvas>

  <div class="cp-list" id="cp-list">
    <h3>Precise Mesh Warp</h3>
    <div class="subtitle">Drag pins to align 1750 features with modern Bronx</div>
    <h4>Control Points</h4>
    <div id="cp-items"></div>
  </div>

  <div class="top-bar">
    <button class="btn btn--secondary" id="reset-btn">Reset All</button>
    <button class="btn btn--secondary" id="upload-btn">Upload Map</button>
    <button class="btn btn--primary" id="save-btn">&#8595; Save Georef JSON</button>
    <input type="file" id="file-input" accept="image/*" style="display:none">
    <input type="file" id="json-input" accept=".json" style="display:none">
    <button class="btn btn--secondary" id="load-btn">&#8593; Load JSON</button>
  </div>

  <div class="bottom-bar">
    <label>Opacity</label>
    <input type="range" id="opacity-slider" min="0" max="100" value="60">
    <span id="opacity-val">60%</span>
    <label style="margin-left:12px">Show Mesh</label>
    <input type="checkbox" id="show-mesh">
  </div>

  <script>
    // ══════════════════════════════════════════════════════════════════════
    //  CONTROL POINTS — pixel positions on the 704×712 image + lat/lng
    // ══════════════════════════════════════════════════════════════════════
    const IMG_W = 704, IMG_H = 712;

    const CONTROL_POINTS = [
      // ── Coastal anchor points (red) ─────────────────────────
      { id: 'throgs-neck',  label: 'Throgs Neck Tip',        imgX: 546, imgY: 649, lat: 40.80500, lng: -73.79500, color: '#ff4444' },
      { id: 'clason-point', label: 'Clason Point',           imgX: 285, imgY: 656, lat: 40.80556, lng: -73.84920, color: '#ff4444' },
      { id: 'hunts-point',  label: 'Hunts Point',            imgX: 160, imgY: 649, lat: 40.80400, lng: -73.88300, color: '#ff4444' },
      { id: 'mott-haven',   label: 'Mott Haven / SW Coast',  imgX:  85, imgY: 654, lat: 40.80800, lng: -73.92600, color: '#ff4444' },

      // ── River / water features (blue) ───────────────────────
      { id: 'bronx-mouth',  label: 'Bronx River Mouth',      imgX: 228, imgY: 590, lat: 40.80860, lng: -73.85800, color: '#44aaff' },
      { id: 'spuyten',      label: 'Spuyten Duyvil (NW)',    imgX: 110, imgY: 185, lat: 40.87500, lng: -73.91810, color: '#44aaff' },

      // ── Northern border points (green) ──────────────────────
      { id: 'nw-border',    label: 'Riverdale / Yonkers',    imgX: 135, imgY:  92, lat: 40.90750, lng: -73.90400, color: '#44ff44' },
      { id: 'ne-border',    label: 'Eastchester / Mt Vernon', imgX: 440, imgY:  82, lat: 40.89820, lng: -73.82000, color: '#44ff44' },

      // ── Islands (orange) ────────────────────────────────────
      { id: 'city-island',  label: 'City Island',            imgX: 500, imgY: 260, lat: 40.84720, lng: -73.78610, color: '#ffaa00' },
      { id: 'hart-island',  label: 'Hart Island',            imgX: 645, imgY: 280, lat: 40.85150, lng: -73.76870, color: '#ffaa00' },

      // ── Image corners (gray) — ensure full coverage ─────────
      // These extend beyond the map features to cover the entire
      // image including title, date, and white borders.
      { id: 'img-nw',       label: 'Image NW Corner',        imgX:   5, imgY:   5, lat: 40.9150, lng: -73.9400, color: '#888888' },
      { id: 'img-ne',       label: 'Image NE Corner',        imgX: 699, imgY:   5, lat: 40.9150, lng: -73.7500, color: '#888888' },
      { id: 'img-se',       label: 'Image SE Corner',        imgX: 699, imgY: 707, lat: 40.7900, lng: -73.7500, color: '#888888' },
      { id: 'img-sw',       label: 'Image SW Corner',        imgX:   5, imgY: 707, lat: 40.7900, lng: -73.9400, color: '#888888' },
    ];

    // ── State ─────────────────────────────────────────────────────────
    let map, handleMarkers = [];
    let currentPoints = CONTROL_POINTS.map(p => ({ ...p }));
    let imageElement = null;
    let triangles = [];
    let showMesh = false;

    // ══════════════════════════════════════════════════════════════════════
    //  DELAUNAY TRIANGULATION (Bowyer-Watson)
    // ══════════════════════════════════════════════════════════════════════
    function delaunayTriangulate(points) {
      const n = points.length;
      if (n < 3) return [];
      const minX = Math.min(...points.map(p => p.x)) - 1;
      const minY = Math.min(...points.map(p => p.y)) - 1;
      const maxX = Math.max(...points.map(p => p.x)) + 1;
      const maxY = Math.max(...points.map(p => p.y)) + 1;
      const dmax = Math.max(maxX - minX, maxY - minY) * 10;
      const superTri = [
        { x: minX - dmax, y: minY - dmax },
        { x: minX + 2 * dmax, y: minY - dmax },
        { x: minX - dmax, y: minY + 2 * dmax },
      ];
      const allPts = points.concat(superTri);
      const sn = n;
      let triList = [[sn, sn + 1, sn + 2]];

      function inCircumcircle(tri, px, py) {
        const [ai, bi, ci] = tri;
        const ax = allPts[ai].x, ay = allPts[ai].y;
        const bx = allPts[bi].x, by = allPts[bi].y;
        const cx = allPts[ci].x, cy = allPts[ci].y;
        const D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
        if (Math.abs(D) < 1e-12) return false;
        const ux = ((ax*ax+ay*ay)*(by-cy)+(bx*bx+by*by)*(cy-ay)+(cx*cx+cy*cy)*(ay-by))/D;
        const uy = ((ax*ax+ay*ay)*(cx-bx)+(bx*bx+by*by)*(ax-cx)+(cx*cx+cy*cy)*(bx-ax))/D;
        return (px-ux)*(px-ux)+(py-uy)*(py-uy) <= (ax-ux)*(ax-ux)+(ay-uy)*(ay-uy);
      }

      for (let i = 0; i < n; i++) {
        const px = points[i].x, py = points[i].y;
        const bad = [];
        for (let t = 0; t < triList.length; t++) {
          if (inCircumcircle(triList[t], px, py)) bad.push(t);
        }
        const edges = [];
        for (const t of bad) {
          const tri = triList[t];
          for (let e = 0; e < 3; e++) {
            const a = tri[e], b = tri[(e+1)%3];
            let shared = false;
            for (const t2 of bad) {
              if (t2 === t) continue;
              const tri2 = triList[t2];
              for (let e2 = 0; e2 < 3; e2++) {
                if ((tri2[e2]===a && tri2[(e2+1)%3]===b)||(tri2[e2]===b && tri2[(e2+1)%3]===a))
                  { shared = true; break; }
              }
              if (shared) break;
            }
            if (!shared) edges.push([a, b]);
          }
        }
        bad.sort((a, b) => b - a);
        for (const t of bad) triList.splice(t, 1);
        for (const [a, b] of edges) triList.push([i, a, b]);
      }
      return triList.filter(tri => tri[0] < n && tri[1] < n && tri[2] < n);
    }

    // ══════════════════════════════════════════════════════════════════════
    //  LAT/LNG → SCREEN PIXEL CONVERSION
    // ══════════════════════════════════════════════════════════════════════
    function latLngToScreenPixel(lat, lng) {
      const proj = map.getProjection();
      if (!proj) return null;
      const worldPoint = proj.fromLatLngToPoint(new google.maps.LatLng(lat, lng));
      const zoom = map.getZoom();
      const scale = Math.pow(2, zoom);
      const bounds = map.getBounds();
      const nw = proj.fromLatLngToPoint(bounds.getNorthEast());
      const sw = proj.fromLatLngToPoint(bounds.getSouthWest());
      // Map div offset
      const mapDiv = map.getDiv();
      const topLeftWorld = proj.fromLatLngToPoint(
        new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getSouthWest().lng())
      );
      const x = (worldPoint.x - topLeftWorld.x) * scale;
      const y = (worldPoint.y - topLeftWorld.y) * scale;
      return { x, y };
    }

    // ══════════════════════════════════════════════════════════════════════
    //  CANVAS 2D TRIANGLE MESH RENDERING
    //  For each triangle: clip to dest triangle, apply affine transform,
    //  draw source image region.
    // ══════════════════════════════════════════════════════════════════════
    function renderOverlay() {
      const canvas = document.getElementById('overlay-canvas');
      const ctx = canvas.getContext('2d');
      const w = window.innerWidth, h = window.innerHeight;
      canvas.width = w * devicePixelRatio;
      canvas.height = h * devicePixelRatio;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      ctx.clearRect(0, 0, w, h);

      if (!imageElement || triangles.length === 0) return;

      const opacity = parseFloat(document.getElementById('opacity-slider').value) / 100;
      ctx.globalAlpha = opacity;

      // Compute screen positions for all control points
      const screenPts = currentPoints.map(cp => latLngToScreenPixel(cp.lat, cp.lng));
      if (screenPts.some(p => !p)) return;

      // Render each triangle
      for (const [i, j, k] of triangles) {
        const sp = [screenPts[i], screenPts[j], screenPts[k]]; // destination (screen)
        const ip = [currentPoints[i], currentPoints[j], currentPoints[k]]; // source (image)

        // Source triangle in image coords
        const sx0 = ip[0].imgX, sy0 = ip[0].imgY;
        const sx1 = ip[1].imgX, sy1 = ip[1].imgY;
        const sx2 = ip[2].imgX, sy2 = ip[2].imgY;

        // Destination triangle in screen coords
        const dx0 = sp[0].x, dy0 = sp[0].y;
        const dx1 = sp[1].x, dy1 = sp[1].y;
        const dx2 = sp[2].x, dy2 = sp[2].y;

        // Compute affine transform: maps (sx,sy) → (dx,dy)
        // | a b c |   | sx0 sx1 sx2 |   | dx0 dx1 dx2 |
        // | d e f | × | sy0 sy1 sy2 | = | dy0 dy1 dy2 |
        //              |  1   1   1  |   |  1   1   1  |
        const det = sx0*(sy1-sy2) + sx1*(sy2-sy0) + sx2*(sy0-sy1);
        if (Math.abs(det) < 0.001) continue;

        const a = (dx0*(sy1-sy2) + dx1*(sy2-sy0) + dx2*(sy0-sy1)) / det;
        const b = (dx0*(sx2-sx1) + dx1*(sx0-sx2) + dx2*(sx1-sx0)) / det;  // note: uses sx not sy
        const c_val = (dx0*(sx1*sy2-sx2*sy1) + dx1*(sx2*sy0-sx0*sy2) + dx2*(sx0*sy1-sx1*sy0)) / det;
        const d = (dy0*(sy1-sy2) + dy1*(sy2-sy0) + dy2*(sy0-sy1)) / det;
        const e = (dy0*(sx2-sx1) + dy1*(sx0-sx2) + dy2*(sx1-sx0)) / det;
        const f = (dy0*(sx1*sy2-sx2*sy1) + dy1*(sx2*sy0-sx0*sy2) + dy2*(sx0*sy1-sx1*sy0)) / det;

        ctx.save();

        // Clip to destination triangle
        ctx.beginPath();
        ctx.moveTo(dx0, dy0);
        ctx.lineTo(dx1, dy1);
        ctx.lineTo(dx2, dy2);
        ctx.closePath();
        ctx.clip();

        // Apply the affine transform and draw the image
        ctx.setTransform(
          a * devicePixelRatio, d * devicePixelRatio,
          b * devicePixelRatio, e * devicePixelRatio,
          c_val * devicePixelRatio, f * devicePixelRatio
        );
        ctx.drawImage(imageElement, 0, 0);

        ctx.restore();
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      }

      // Draw mesh wireframe if enabled
      if (showMesh) {
        ctx.globalAlpha = 1;
        ctx.strokeStyle = 'rgba(255,255,0,0.5)';
        ctx.lineWidth = 1;
        for (const [i, j, k] of triangles) {
          const sp = [screenPts[i], screenPts[j], screenPts[k]];
          ctx.beginPath();
          ctx.moveTo(sp[0].x, sp[0].y);
          ctx.lineTo(sp[1].x, sp[1].y);
          ctx.lineTo(sp[2].x, sp[2].y);
          ctx.closePath();
          ctx.stroke();
        }
      }
    }

    // ══════════════════════════════════════════════════════════════════════
    //  TRIANGULATION
    // ══════════════════════════════════════════════════════════════════════
    function recomputeTriangulation() {
      const pts = currentPoints.map(cp => ({ x: cp.imgX, y: cp.imgY }));
      triangles = delaunayTriangulate(pts);
      renderOverlay();
    }

    // ══════════════════════════════════════════════════════════════════════
    //  CONTROL POINT LIST UI
    // ══════════════════════════════════════════════════════════════════════
    function renderCPList() {
      const container = document.getElementById('cp-items');
      container.innerHTML = '';
      currentPoints.forEach((cp, i) => {
        const item = document.createElement('div');
        item.className = 'cp-item';
        item.innerHTML = `
          <span class="dot" style="background:${cp.color}"></span>
          <span class="name">${cp.label}</span>
          <span class="coords">${cp.lat.toFixed(4)}, ${cp.lng.toFixed(4)}</span>
        `;
        item.addEventListener('click', () => {
          map.panTo({ lat: cp.lat, lng: cp.lng });
          map.setZoom(14);
        });
        container.appendChild(item);
      });
    }

    // ══════════════════════════════════════════════════════════════════════
    //  IMAGE LOADING
    // ══════════════════════════════════════════════════════════════════════
    function loadImage(src) {
      return new Promise(resolve => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          imageElement = img;
          recomputeTriangulation();
          resolve(img);
        };
        img.onerror = () => {
          console.error('Failed to load image:', src);
          resolve(null);
        };
        img.src = src;
      });
    }

    // ══════════════════════════════════════════════════════════════════════
    //  SAVE / LOAD JSON
    // ══════════════════════════════════════════════════════════════════════
    function saveJSON() {
      const data = {
        controlPoints: currentPoints.map(cp => ({
          id: cp.id, label: cp.label,
          imgX: cp.imgX, imgY: cp.imgY,
          lat: cp.lat, lng: cp.lng,
        })),
        triangles,
        imageSize: { width: IMG_W, height: IMG_H },
        opacity: parseFloat(document.getElementById('opacity-slider').value) / 100,
        savedAt: new Date().toISOString(),
        tool: 'georef-precise (multi-point mesh warp)',
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'georef-mesh-1750-bronx.json';
      a.click();
    }

    function loadJSON(file) {
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          if (data.controlPoints) {
            data.controlPoints.forEach(loaded => {
              const idx = currentPoints.findIndex(cp => cp.id === loaded.id);
              if (idx >= 0) {
                currentPoints[idx].lat = loaded.lat;
                currentPoints[idx].lng = loaded.lng;
                if (loaded.imgX != null) currentPoints[idx].imgX = loaded.imgX;
                if (loaded.imgY != null) currentPoints[idx].imgY = loaded.imgY;
                if (handleMarkers[idx]) {
                  handleMarkers[idx].position = { lat: loaded.lat, lng: loaded.lng };
                }
              }
            });
            recomputeTriangulation();
            renderCPList();
          }
          if (data.opacity != null) {
            const pct = Math.round(data.opacity * 100);
            document.getElementById('opacity-slider').value = pct;
            document.getElementById('opacity-val').textContent = pct + '%';
          }
        } catch (err) { alert('Invalid JSON: ' + err.message); }
      };
      reader.readAsText(file);
    }

    // ══════════════════════════════════════════════════════════════════════
    //  MARKERS
    // ══════════════════════════════════════════════════════════════════════
    function createMarkers() {
      handleMarkers.forEach(m => m.map = null);
      handleMarkers = [];

      currentPoints.forEach((cp, i) => {
        const pin = document.createElement('div');
        pin.style.cssText = `
          width: 18px; height: 18px; border-radius: 50%;
          background: ${cp.color}; border: 2px solid #fff;
          box-shadow: 0 2px 6px rgba(0,0,0,.5);
          cursor: grab; position: relative;
        `;
        pin.title = cp.label;

        const lbl = document.createElement('div');
        lbl.style.cssText = `
          position: absolute; top: -22px; left: 50%; transform: translateX(-50%);
          white-space: nowrap; font-size: 10px; font-weight: 700;
          color: #fff; background: rgba(0,0,0,.7); padding: 2px 6px;
          border-radius: 4px; pointer-events: none;
        `;
        lbl.textContent = cp.label;
        pin.appendChild(lbl);

        const marker = new google.maps.marker.AdvancedMarkerElement({
          map, position: { lat: cp.lat, lng: cp.lng },
          content: pin, gmpDraggable: true, zIndex: 100 + i,
        });

        marker.addListener('drag', () => {
          const pos = marker.position;
          currentPoints[i].lat = pos.lat;
          currentPoints[i].lng = pos.lng;
          renderOverlay();
        });
        marker.addListener('dragend', () => {
          const pos = marker.position;
          currentPoints[i].lat = pos.lat;
          currentPoints[i].lng = pos.lng;
          recomputeTriangulation();
          renderCPList();
        });

        handleMarkers.push(marker);
      });
    }

    // ══════════════════════════════════════════════════════════════════════
    //  INIT
    // ══════════════════════════════════════════════════════════════════════
    async function initMap() {
      const { Map } = await google.maps.importLibrary('maps');
      await google.maps.importLibrary('marker');

      map = new Map(document.getElementById('map'), {
        center: { lat: 40.8448, lng: -73.8648 },
        zoom: 12,
        mapId: 'a9461ba5f543306b87fc900f',
        disableDefaultUI: false,
        mapTypeControl: true,
        gestureHandling: 'greedy',
      });

      createMarkers();
      renderCPList();
      await loadImage('BlacksInTheColonialBronx.png');

      // Redraw on any map change
      map.addListener('bounds_changed', renderOverlay);
      map.addListener('zoom_changed', renderOverlay);
      map.addListener('idle', renderOverlay);

      // UI wiring
      document.getElementById('opacity-slider').addEventListener('input', e => {
        document.getElementById('opacity-val').textContent = e.target.value + '%';
        renderOverlay();
      });
      document.getElementById('show-mesh').addEventListener('change', e => {
        showMesh = e.target.checked;
        renderOverlay();
      });
      document.getElementById('save-btn').addEventListener('click', saveJSON);
      document.getElementById('load-btn').addEventListener('click', () =>
        document.getElementById('json-input').click());
      document.getElementById('json-input').addEventListener('change', e => {
        if (e.target.files[0]) loadJSON(e.target.files[0]);
      });
      document.getElementById('upload-btn').addEventListener('click', () =>
        document.getElementById('file-input').click());
      document.getElementById('file-input').addEventListener('change', e => {
        if (e.target.files[0]) loadImage(URL.createObjectURL(e.target.files[0]));
      });
      document.getElementById('reset-btn').addEventListener('click', () => {
        if (!confirm('Reset all control points to defaults?')) return;
        currentPoints = CONTROL_POINTS.map(p => ({ ...p }));
        createMarkers();
        recomputeTriangulation();
        renderCPList();
      });
    }
  </script>

  <script>
    (async () => {
      const s = document.createElement('script');
      s.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyDODtJJwm_y9aQieG3gE3_wAi4bjL7bfvg&v=weekly&libraries=marker';
      document.head.appendChild(s);
      await new Promise(r => s.onload = r);
      initMap();
    })();
  </script>
</body>
</html>
